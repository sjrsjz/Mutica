use crate::parser::ast::TypeAst;
use lalrpop_util::ErrorRecovery;
use crate::parser::lexer::{LexerToken, LexicalError};
use crate::parser::SourceFile;
use crate::parser::SourceLocation;
use crate::parser::WithLocation;
use std::sync::Arc;
grammar<'input>(source: &Arc<SourceFile>);



extern {
    type Location = usize;
    type Error = LexicalError;

    enum LexerToken<'input> {
        r"[0-9]+" => LexerToken::Num(<&'input str>),
        r"[a-zA-Z_][a-zA-Z0-9_]*" => LexerToken::Ident(<&'input str>),
        r"'(\\'|\x22|\\n|\\r|\\t|\\\\|[^'\\])'" => LexerToken::CharLit(<&'input str>),
        r#""([^"\\]|\\.)*""# => LexerToken::StringLit(<&'input str>),

        "let" => LexerToken::Let,
        "perform" => LexerToken::Perform,
        "do" => LexerToken::Do,
        "with" => LexerToken::With,
        "as" => LexerToken::As,
        "match" => LexerToken::Match,
        "rec" => LexerToken::Rec,
        "panic" => LexerToken::Panic,
        "discard" => LexerToken::Discard,
        "int" => LexerToken::Int,
        "char" => LexerToken::Char,
        "true" => LexerToken::True,
        "false" => LexerToken::False,
        "any" => LexerToken::Any,
        "none" => LexerToken::None,
        "__add" => LexerToken::DunderAdd,
        "__sub" => LexerToken::DunderSub,
        "__mul" => LexerToken::DunderMul,
        "__div" => LexerToken::DunderDiv,
        "__mod" => LexerToken::DunderMod,
        "__is" => LexerToken::DunderIs,
        "__opcode" => LexerToken::DunderOpcode,
        "__continuation" => LexerToken::DunderContinuation,
        "input" => LexerToken::Input,
        "print" => LexerToken::Print,

        "->" => LexerToken::Arrow,
        "|->" => LexerToken::FatArrow,
        "=>" => LexerToken::DoubleArrow,
        "::" => LexerToken::DoubleColon,
        "." => LexerToken::Dot,
        "@" => LexerToken::At,
        "|" => LexerToken::Pipe,
        "!" => LexerToken::Bang,
        ":" => LexerToken::Colon,
        "~" => LexerToken::Tilde,
        "," => LexerToken::Comma,
        "&" => LexerToken::Ampersand,
        "==" => LexerToken::Eq,
        "!=" => LexerToken::Neq,
        "<" => LexerToken::Lt,
        "<=" => LexerToken::Lte,
        ">" => LexerToken::Gt,
        ">=" => LexerToken::Gte,
        "<:" => LexerToken::Subtype,
        "+" => LexerToken::Plus,
        "-" => LexerToken::Minus,
        "*" => LexerToken::Star,
        "/" => LexerToken::Slash,
        "%" => LexerToken::Percent,
        "=" => LexerToken::Assign,
        ";" => LexerToken::Semicolon,
        "#" => LexerToken::Hash,
        "\\" => LexerToken::Backslash,
        "(" => LexerToken::LParen,
        ")" => LexerToken::RParen,
        "[" => LexerToken::LBracket,
        "]" => LexerToken::RBracket,
        "{" => LexerToken::LBrace,
        "}" => LexerToken::RBrace,
        "|>" => LexerToken::PipeGreaterThan,
    }
}

Num: isize = <s:r"[0-9]+"> => s.parse().unwrap();
Ident: String = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string();

CharLiteral: char = {
    <c:r"'(\\'|\x22|\\n|\\r|\\t|\\\\|[^'\\])'"> => {
        let content = &c[1..c.len()-1];
        match content {
            "\\n" => '\n', "\\r" => '\r', "\\t" => '\t',
            "\\'" => '\'', "\\\"" => '\"', "\\\\" => '\\',
            s if s.len() == 1 => s.chars().next().unwrap(),
            _ => unreachable!(),
        }
    }
};

StringLiteral: String = {
    <s:r#""([^"\\]|\\.)*""#> => {
        let content = &s[1..s.len()-1];
        content.replace("\\n", "\n")
               .replace("\\r", "\r")
               .replace("\\t", "\t")
               .replace("\\\"", "\"")
               .replace("\\\\", "\\")
    }
};


AtomType: WithLocation<TypeAst<'input>> = {
    <l:@L> "int" <r:@R> => WithLocation::new(TypeAst::Int, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "char" <r:@R> => WithLocation::new(TypeAst::Char, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "true" <r:@R> => WithLocation::new(TypeAst::Top, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "false" <r:@R> => WithLocation::new(TypeAst::Bottom, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "any" <r:@R> => WithLocation::new(TypeAst::Top, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "none" <r:@R> => WithLocation::new(TypeAst::Bottom, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "__add" <r:@R> => WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Add), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "__sub" <r:@R> => WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Sub), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "__mul" <r:@R> => WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Mul), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "__div" <r:@R> => WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Div), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "__mod" <r:@R> => WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Mod), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "__is" <r:@R> => WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Is), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "__opcode" <r:@R> => WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Opcode), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "input" <r:@R> => WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Input), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "print" <r:@R> => WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Print), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> "__continuation" <r:@R> => WithLocation::new(TypeAst::Variable(None), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <n: Num> <r:@R> => WithLocation::new(TypeAst::IntLiteral(n), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <id: Ident> <r:@R> => WithLocation::new(TypeAst::Variable(Some(id)), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <c: CharLiteral> <r:@R> => WithLocation::new(TypeAst::CharLiteral(c), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <s: StringLiteral> <r:@R> => {
        let chars: Vec<WithLocation<TypeAst<'input>>> = s.chars().map(|ch| WithLocation::new(TypeAst::CharLiteral(ch), Some(SourceLocation::new(source.clone(), l..r)).as_ref())).collect();
        WithLocation::new(TypeAst::List(chars), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
}

Term: WithLocation<TypeAst<'input>> = {
    "(" <t: Type> ")" => t,
    "[" <t: Type> "]" => t,
    "{" <t: Type> "}" => t,
    <np: Namespace> => np,
    <a: AtomType> => a,
}

Namespace: WithLocation<TypeAst<'input>> = {
    <l:@L> <tag: Ident> "::" <t: Term> <r:@R> => WithLocation::new(TypeAst::Namespace {
        tag: tag,
        expr: Box::new(t),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
}

Apply: WithLocation<TypeAst<'input>> = {
    <l:@L> <obj: Apply> "." <k: Ident> <r:@R> => WithLocation::new(TypeAst::Apply {
        func: Box::new(WithLocation::new(TypeAst::Closure {
            pattern: Box::new(WithLocation::new(TypeAst::Namespace {
                tag: k,
                expr: Box::new(WithLocation::new(TypeAst::Pattern {
                    name: "projection#obj".to_string(),
                    expr: Box::new(WithLocation::new(TypeAst::Top, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
                }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            body: Box::new(WithLocation::new(TypeAst::Variable(Some("projection#obj".to_string())), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            fail_branch: None,
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        arg: Box::new(obj),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <f: Apply> <x: Term> "|>" <k: Term> <r:@R> => WithLocation::new(TypeAst::Invoke {
        func: Box::new(f),
        arg: Box::new(x),
        continuation: Box::new(k),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <f: Apply> <x: Term> <r:@R> => WithLocation::new(TypeAst::Apply {
        func: Box::new(f),
        arg: Box::new(x),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <t: Term> => t,
}

List: WithLocation<TypeAst<'input>> = {
    <l:@L> "@" <element: Primary> <r:@R> => match element.value() {
        TypeAst::Tuple(elements) => WithLocation::new(TypeAst::List(elements.clone()), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
        single => WithLocation::new(TypeAst::List(vec![WithLocation::new(single.clone(), element.location())]), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    },
}

Match: WithLocation<TypeAst<'input>> = {
    <l:@L> "match" <value: Primary> <branches: MatchBranch+> <else_branch: ElseBranch> <r:@R> => {
        WithLocation::new(TypeAst::Match {
            value: Box::new(value),
            match_branch: branches,
            else_branch: Some(Box::new(else_branch)),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "match" <value: Primary> <branches: MatchBranch+> "|" "panic" <r:@R> => {
        WithLocation::new(TypeAst::Match {
            value: Box::new(value),
            match_branch: branches,
            else_branch: None,
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
}

MatchBranch: (WithLocation<TypeAst<'input>>, WithLocation<TypeAst<'input>>) = {
    "|" <pattern: Primary> "=>" <t: Primary> => (pattern, t),
}

ElseBranch: WithLocation<TypeAst<'input>> = {
    "|" "!" "=>" <t: Primary> => t,
}

RecursiveGen: WithLocation<TypeAst<'input>> = {
    <l:@L> "rec" <id: Ident> ":" <t: Primary> <r:@R> => WithLocation::new(TypeAst::FixPoint {
        param_name: id,
        expr: Box::new(t),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
}

FailBranch: Box<WithLocation<TypeAst<'input>>> = {
    "\\" <t: Primary> => Box::new(t),
}

Closure: WithLocation<TypeAst<'input>> = {
    <l:@L> <pattern: Factor> "->" <body: Primary> <fail_branch: FailBranch> <r:@R> => {
        WithLocation::new(TypeAst::Closure {
            pattern: Box::new(pattern),
            body: Box::new(body),
            fail_branch: Some(fail_branch),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <pattern: Factor> "|->" <body: Primary> <r:@R> => {
        WithLocation::new(TypeAst::Closure {
            pattern: Box::new(pattern),
            body: Box::new(body),
            fail_branch: None,
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    }
}

Tuple: WithLocation<TypeAst<'input>> = {
    <l:@L> <r:@R> => WithLocation::new(TypeAst::Tuple(vec![]), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <items: Comma<TupleElement>> <r:@R> => WithLocation::new(TypeAst::Tuple(items), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <item: TupleElement> => item,
}

// Define Comma<T> for one or more comma-separated items.
Comma<T>: Vec<T> = {
    <v:(T CommaSep)+> <e:T> => {
        let mut res = Vec::new();
        for (it, _sep) in v.into_iter() {
            res.push(it);
        }
        res.push(e);
        res
    },
    <e:T> CommaSep => vec![e],
};

CommaSep = ","+;


Literal: WithLocation<TypeAst<'input>> = {
    <l:@L> "#" <t: Primary> <r:@R> => WithLocation::new(TypeAst::Literal(Box::new(t)), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
}

Primary: WithLocation<TypeAst<'input>> = {
    <l: Literal> => l,
    <l: List> => l,
    <r: RecursiveGen> => r,
    <c: Closure> => c,
    <m: Match> => m,
    <c: Calculate> => c,
    ! => {
        let err: ErrorRecovery<usize, LexerToken<'input>, LexicalError> = <>;
        WithLocation::new(TypeAst::ParseError(err), None::<&SourceLocation>)
    }
};

Factor: WithLocation<TypeAst<'input>> = {
    <l:@L> "!" <a: Factor> <r:@R> => WithLocation::new(TypeAst::Not {
        value: Box::new(a),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <id: Ident> ":" <a: Factor> <r:@R> => WithLocation::new(TypeAst::Pattern {
        name: id,
        expr: Box::new(a),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <a: Apply> => a,
}


TupleElement = Generalize;

Generalize: WithLocation<TypeAst<'input>> = {
    <l:@L> <items: Bars<Specialize>> <r:@R> => WithLocation::new(TypeAst::Generalize(items), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <e: Specialize> => e,
}

Bars<T>: Vec<T> = {
    <v:(T BarsSep)+> <e:T> => {
        let mut res = Vec::new();
        for (it, _sep) in v.into_iter() {
            res.push(it);
        }
        res.push(e);
        res
    },
};

BarsSep = "|" +;

Specialize: WithLocation<TypeAst<'input>> = {
    <l:@L> <items: Ands<Primary>> <r:@R> => WithLocation::new(TypeAst::Specialize(items), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <e: Primary> => e,
}

Ands<T>: Vec<T> = {
    <v:(T AndsSep)+> <e:T> => {
        let mut res = Vec::new();
        for (it, _sep) in v.into_iter() {
            res.push(it);
        }
        res.push(e);
        res
    },
    <e:T> AndsSep => vec![e],
};

AndsSep = "&"+;


Calculate: WithLocation<TypeAst<'input>> = { Compare };

Compare: WithLocation<TypeAst<'input>> = {
    <l:@L> <left: Compare> "==" <right: AddSub> <r:@R> => WithLocation::new(TypeAst::Eq {
        left: Box::new(left),
        right: Box::new(right),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <left: Compare> "!=" <right: AddSub> <r:@R> => WithLocation::new(TypeAst::Neq {
        left: Box::new(left),
        right: Box::new(right),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <left: Compare> "<" <right: AddSub> <r:@R> => WithLocation::new(TypeAst::Apply {
        func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Less), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <left: Compare> "<=" <right: AddSub> <r:@R> => WithLocation::new(TypeAst::Generalize(vec![
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Less), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left.clone(), right.clone()]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
        WithLocation::new(TypeAst::Eq {
            left: Box::new(left),
            right: Box::new(right),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    ]), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <left: Compare> ">" <right: AddSub> <r:@R> => WithLocation::new(TypeAst::Apply {
        func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Greater), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <left: Compare> ">=" <right: AddSub> <r:@R> => WithLocation::new(TypeAst::Generalize(vec![
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Greater), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left.clone(), right.clone()]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
        WithLocation::new(TypeAst::Eq {
            left: Box::new(left),
            right: Box::new(right),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    ]), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <left: Compare> "<:" <right: AddSub> <r:@R> => WithLocation::new(TypeAst::Apply {
        func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Is), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <t: AddSub> => t,
}

AddSub: WithLocation<TypeAst<'input>> = {
    <l:@L> <left: AddSub> "+" <right: Mod> <r:@R> => WithLocation::new(TypeAst::Apply {
        func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Add), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <left: AddSub> "-" <right: Mod> <r:@R> => WithLocation::new(TypeAst::Apply {
        func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Sub), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <t: Mod> => t,
}

Mod: WithLocation<TypeAst<'input>> = {
    <l:@L> <left: Mod> "%" <right: MulDiv> <r:@R> => WithLocation::new(TypeAst::Apply {
        func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Mod), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <t: MulDiv> => t,
}

MulDiv: WithLocation<TypeAst<'input>> = {
    <l:@L> <left: MulDiv> "*" <right: Factor> <r:@R> => WithLocation::new(TypeAst::Apply {
        func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Mul), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <left: MulDiv> "/" <right: Factor> <r:@R> => WithLocation::new(TypeAst::Apply {
        func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Div), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <t: Factor> => t,
}

Let: (WithLocation<TypeAst<'input>>, WithLocation<TypeAst<'input>>) = {
    "let" <id: Primary> "=" <value: Type> ";" => (id, value),
}

Perform: (WithLocation<TypeAst<'input>>, WithLocation<TypeAst<'input>>, WithLocation<TypeAst<'input>>) = {
    "perform" <id: Primary> "=" <f: Type> "with" <value: Type> ";" => (id, f, value),
}

DiscardPerform: (WithLocation<TypeAst<'input>>, WithLocation<TypeAst<'input>>) = {
    "perform" <f: Type> "with"  <e: Type> ";" => (f, e),
}

Discard: WithLocation<TypeAst<'input>> = {
    "discard" <e: Type> ";" => e,
}

Expression: WithLocation<TypeAst<'input>> = {
    <l:@L> <let_expr: Let> <e: Type> <r:@R> => {
        match e.value() {
            TypeAst::Expression {
                binding_patterns,
                binding_types,
                body,
            } => {
                let mut new_patterns = binding_patterns.clone();
                let mut new_types = binding_types.clone();
                new_patterns.insert(0, let_expr.0);
                new_types.insert(0, let_expr.1);
                WithLocation::new(TypeAst::Expression {
                    binding_patterns: new_patterns,
                    binding_types: new_types,
                    body: body.clone(),
                }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
            }
            _ => WithLocation::new(TypeAst::Expression {
                binding_patterns: vec![let_expr.0],
                binding_types: vec![let_expr.1],
                body: Box::new(e),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
        }
    },
    <l:@L> <discard_expr: Discard> <e: Type> <r:@R> => {
        match e.value() {
            TypeAst::Expression {
                binding_patterns,
                binding_types,
                body,
            } => {
                let mut new_patterns = binding_patterns.clone();
                let mut new_types = binding_types.clone();
                new_patterns.insert(0, WithLocation::new(TypeAst::DiscardPattern, Some(SourceLocation::new(source.clone(), l..r)).as_ref()));
                new_types.insert(0, discard_expr);
                WithLocation::new(TypeAst::Expression {
                    binding_patterns: new_patterns,
                    binding_types: new_types,
                    body: body.clone(),
                }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
            }
            _ => WithLocation::new(TypeAst::Expression {
                binding_patterns: vec![WithLocation::new(TypeAst::DiscardPattern, Some(SourceLocation::new(source.clone(), l..r)).as_ref())],
                binding_types: vec![discard_expr],
                body: Box::new(e),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
        }
    },
}

Effect: WithLocation<TypeAst<'input>> = {
    <l:@L> <perform_expr: Perform> <e: Type> <r:@R> => {
        WithLocation::new(TypeAst::Invoke {
            func: Box::new(perform_expr.1),
            arg: Box::new(perform_expr.2),
            continuation: Box::new(WithLocation::new(TypeAst::Closure {
                pattern: Box::new(perform_expr.0),
                body: Box::new(e),
                fail_branch: None,
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <discard_perform: DiscardPerform> <e: Type> <r:@R> => {
        WithLocation::new(TypeAst::Invoke {
            func: Box::new(discard_perform.0),
            arg: Box::new(discard_perform.1),
            continuation: Box::new(WithLocation::new(TypeAst::Closure {
                pattern: Box::new(WithLocation::new(TypeAst::DiscardPattern, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
                body: Box::new(e),
                fail_branch: None,
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
}


pub Type: WithLocation<TypeAst<'input>> = {
    <e: Effect> => e,
    <e: Expression> => e,
    <t: Tuple> => t,
}
