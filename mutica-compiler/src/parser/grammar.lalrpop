use crate::parser::ast::TypeAst;
use lalrpop_util::ErrorRecovery;
use crate::parser::lexer::{LexerToken, LexicalError};
use crate::parser::SourceFile;
use crate::parser::SourceLocation;
use crate::parser::WithLocation;
use crate::parser::calculate_full_error_span;
use crate::parser::colorize::TokenColor;
use std::sync::Arc;
grammar(source: &Arc<SourceFile>, colors: &mut Vec<TokenColor>);



extern {
    type Location = usize;
    type Error = LexicalError;

    enum LexerToken {
        "_" => LexerToken::Wildcard,
        r"[0-9]+\.[0-9]*([eE][+-]?[0-9]+)?|\.[0-9]+([eE][+-]?[0-9]+)?|[0-9]+[eE][+-]?[0-9]+" => LexerToken::FloatNum(<String>),
        r"[0-9]+" => LexerToken::Num(<String>),
        r"[a-zA-Z_][a-zA-Z0-9_]*" => LexerToken::Ident(<String>),
        r"'(\\'|\x22|\\n|\\r|\\t|\\\\|[^'\\])'" => LexerToken::CharLit(<String>),
        r#""([^"\\]|\\.)*""# => LexerToken::StringLit(<String>),

        "let" => LexerToken::Let,
        "with" => LexerToken::With,
        "match" => LexerToken::Match,
        "rec" => LexerToken::Rec,
        "loop" => LexerToken::Loop,
        "panic" => LexerToken::Panic,
        "discard" => LexerToken::Discard,
        "int" => LexerToken::Int,
        "char" => LexerToken::Char,
        "float" => LexerToken::Float,
        "true" => LexerToken::True,
        "false" => LexerToken::False,
        "any" => LexerToken::Any,
        "none" => LexerToken::None,
        "import" => LexerToken::Import,
        "if" => LexerToken::If,
        "then" => LexerToken::Then,
        "else" => LexerToken::Else,
        "rot" => LexerToken::Rot,
        "handle" => LexerToken::Handle,
        "__add" => LexerToken::DunderAdd,
        "__sub" => LexerToken::DunderSub,
        "__mul" => LexerToken::DunderMul,
        "__div" => LexerToken::DunderDiv,
        "__mod" => LexerToken::DunderMod,
        "__greater" => LexerToken::DunderGreater,
        "__less" => LexerToken::DunderLess,
        "__is" => LexerToken::DunderIs,
        "__opcode" => LexerToken::DunderOpcode,

        "->" => LexerToken::Arrow,
        "|->" => LexerToken::FatArrow,
        "=>" => LexerToken::DoubleArrow,
        "::" => LexerToken::DoubleColon,
        "." => LexerToken::Dot,
        "@" => LexerToken::At,
        "|" => LexerToken::Pipe,
        "!" => LexerToken::Bang,
        ":" => LexerToken::Colon,
        "~" => LexerToken::Tilde,
        "," => LexerToken::Comma,
        "&" => LexerToken::Ampersand,
        "==" => LexerToken::Eq,
        "!=" => LexerToken::Neq,
        "<" => LexerToken::Lt,
        "<=" => LexerToken::Lte,
        ">" => LexerToken::Gt,
        ">=" => LexerToken::Gte,
        "<:" => LexerToken::Subtype,
        "+" => LexerToken::Plus,
        "-" => LexerToken::Minus,
        "*" => LexerToken::Star,
        "/" => LexerToken::Slash,
        "%" => LexerToken::Percent,
        "=" => LexerToken::Assign,
        ";" => LexerToken::Semicolon,
        "#" => LexerToken::Hash,
        "\\" => LexerToken::Backslash,
        "(" => LexerToken::LParen,
        ")" => LexerToken::RParen,
        "[" => LexerToken::LBracket,
        "]" => LexerToken::RBracket,
        "{" => LexerToken::LBrace,
        "}" => LexerToken::RBrace,
        "|>" => LexerToken::PipeGreaterThan,
        ".." => LexerToken::Range,
    }
}

Num: i64 = <l:@L> <s:r"[0-9]+"> <r:@R> => {
    TokenColor::fill_colors(colors, l..r, TokenColor::Number);
    if s.starts_with("0x") || s.starts_with("0X") {
        i64::from_str_radix(&s[2..], 16).unwrap()
    } else if s.starts_with("0o") || s.starts_with("0O") {
        i64::from_str_radix(&s[2..], 8).unwrap()
    } else if s.starts_with("0b") || s.starts_with("0B") {
        i64::from_str_radix(&s[2..], 2).unwrap()
    } else {
        s.parse().unwrap()
    }
};

Float: f64 = <l:@L> <s:r"[0-9]+\.[0-9]*([eE][+-]?[0-9]+)?|\.[0-9]+([eE][+-]?[0-9]+)?|[0-9]+[eE][+-]?[0-9]+"> <r:@R> => {
    TokenColor::fill_colors(colors, l..r, TokenColor::Number);
    s.parse().unwrap()
};

Ident: String = <l:@L> <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> <r:@R> => {
    TokenColor::fill_colors(colors, l..r, TokenColor::Identifier);
    s.to_string()
};

CharLiteral: char = {
    <l:@L> <c:r"'(\\'|\x22|\\n|\\r|\\t|\\\\|[^'\\])'"> <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::String);
        let content = &c[1..c.len()-1];
        match content {
            "\\n" => '\n', "\\r" => '\r', "\\t" => '\t',
            "\\'" => '\'', "\\\"" => '\"', "\\\\" => '\\',
            s if s.len() == 1 => s.chars().next().unwrap(),
            _ => unreachable!(),
        }
    }
};

StringLiteral: String = {
    <l:@L> <s:r#""([^"\\]|\\.)*""#> <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::String);
        let content = &s[1..s.len()-1];
        content.replace("\\n", "\n")
               .replace("\\r", "\r")
               .replace("\\t", "\t")
               .replace("\\\"", "\"")
               .replace("\\\\", "\\")
    }
};


AtomType: WithLocation<TypeAst> = {
    <l:@L> "int" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Type);
        WithLocation::new(TypeAst::Int, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "float" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Type);
        WithLocation::new(TypeAst::Float, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "char" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Type);
        WithLocation::new(TypeAst::Char, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "true" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Type);
        WithLocation::new(TypeAst::Top, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "false" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Type);
        WithLocation::new(TypeAst::Bottom, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "any" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Type);
        WithLocation::new(TypeAst::Top, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "_" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Type);
        WithLocation::new(TypeAst::Top, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "none" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Type);
        WithLocation::new(TypeAst::Bottom, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "__add" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Keyword);
        WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Add), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "__sub" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Keyword);
        WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Sub), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "__mul" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Keyword);
        WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Mul), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "__div" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Keyword);
        WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Div), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "__mod" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Keyword);
        WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Mod), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "__is" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Keyword);
        WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Is), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "__greater" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Keyword);
        WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Greater), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "__less" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Keyword);
        WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Less), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "__opcode" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Keyword);
        WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Opcode), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <f: Float> <r:@R> => WithLocation::new(TypeAst::FloatLiteral(f), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <n: Num> <r:@R> => WithLocation::new(TypeAst::IntLiteral(n), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <id: Ident> <r:@R> => WithLocation::new(TypeAst::Variable(id), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <c: CharLiteral> <r:@R> => WithLocation::new(TypeAst::CharLiteral(c), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <s: StringLiteral> <r:@R> => {
        let chars: Vec<WithLocation<TypeAst>> = s.chars().map(|ch| WithLocation::new(TypeAst::CharLiteral(ch), Some(SourceLocation::new(source.clone(), l..r)).as_ref())).collect();
        WithLocation::new(TypeAst::List(chars), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <io: Ident> "!" <r:@R> => {
        TokenColor::fill_colors(colors, l..r, TokenColor::Function);
        WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::IO(io)), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "import" <s: StringLiteral> <r:@R> => {
        TokenColor::fill_colors(colors, l..l+6, TokenColor::Keyword);
        WithLocation::new(TypeAst::Import(s), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
}

Term: WithLocation<TypeAst> = {
    <lparen_l:@L> "(" <lparen_r:@R> <t: Type> <rparen_l:@L> ")" <rparen_r:@R> => {
        TokenColor::fill_colors(colors, lparen_l..lparen_r, TokenColor::Punctuation);
        TokenColor::fill_colors(colors, rparen_l..rparen_r, TokenColor::Punctuation);
        t
    },
    <lbracket_l:@L> "[" <lbracket_r:@R> <t: Type> <rbracket_l:@L> "]" <rbracket_r:@R> => {
        TokenColor::fill_colors(colors, lbracket_l..lbracket_r, TokenColor::Punctuation);
        TokenColor::fill_colors(colors, rbracket_l..rbracket_r, TokenColor::Punctuation);
        t
    },
    <lbrace_l:@L> "{" <lbrace_r:@R> <t: Type> <rbrace_l:@L> "}" <rbrace_r:@R> => {
        TokenColor::fill_colors(colors, lbrace_l..lbrace_r, TokenColor::Punctuation);
        TokenColor::fill_colors(colors, rbrace_l..rbrace_r, TokenColor::Punctuation);
        t
    },
    <rot: Rot> => rot,
    <np: Namespace> => np,
    <a: AtomType> => a,
}

Namespace: WithLocation<TypeAst> = {
    <l:@L> <n_l:@L> <tag: Ident> <n_r:@R> <colon_l:@L> "::" <colon_r:@R> <t: Term> <r:@R> => {
        TokenColor::fill_colors(colors, n_l..n_r, TokenColor::Namespace);
        TokenColor::fill_colors(colors, colon_l..colon_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Namespace {
            tag: tag,
            expr: Box::new(t),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
}

Rot: WithLocation<TypeAst> = {
    <l:@L> <rot_l:@L> "rot" <rot_r:@R> <a: Term> <r:@R> => {
        TokenColor::fill_colors(colors, rot_l..rot_r, TokenColor::Keyword);
        WithLocation::new(TypeAst::Rot {
            value: Box::new(a),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
}

Apply: WithLocation<TypeAst> = {
    <l:@L> <obj: Apply> <dot_l:@L> "." <dot_r:@R> <a_l:@L> <k: Ident> <a_r:@R> <r:@R> => {
        TokenColor::fill_colors(colors, dot_l..dot_r, TokenColor::Operator);
        TokenColor::fill_colors(colors, a_l..a_r, TokenColor::Attribute);
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::Match {
                branches: vec![(WithLocation::new(TypeAst::Namespace {
                    tag: k,
                    expr: Box::new(WithLocation::new(TypeAst::Pattern {
                        name: "projection#obj".to_string(),
                        expr: Box::new(WithLocation::new(TypeAst::Top, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
                    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
                }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
                WithLocation::new(TypeAst::Variable("projection#obj".to_string()), Some(SourceLocation::new(source.clone(), l..r)).as_ref()))]
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(obj),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <f: Apply> <x: Term> <pipe_l:@L> "|>" <pipe_r:@R> <k: Term> <r:@R> => {
        TokenColor::fill_colors(colors, pipe_l..pipe_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Invoke {
            func: Box::new(f),
            arg: Box::new(x),
            continuation: Some(Box::new(k)),
            perform_handler: None,
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <f: Apply> <x: Term> <r:@R> => WithLocation::new(TypeAst::Apply {
        func: Box::new(f),
        arg: Box::new(x),
    }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <t: Term> => t,
}

List: WithLocation<TypeAst> = {
    <l:@L> <at_l:@L> "@" <at_r:@R> <element: Primary> <r:@R> => {
        TokenColor::fill_colors(colors, at_l..at_r, TokenColor::Operator);
        match element.value() {
            TypeAst::Tuple(elements) => WithLocation::new(TypeAst::List(elements.clone()), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
            single => WithLocation::new(TypeAst::List(vec![WithLocation::new(single.clone(), element.location())]), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
        }
    },
}

IfElse: WithLocation<TypeAst> = {
    <l:@L> "if" <cond: Primary?> <then_l:@L> "then" <then_r:@R> <then_branch: Primary> <else_l:@L> "else" <else_r:@R> <else_branch: Primary> <r:@R> => {
        TokenColor::fill_colors(colors, l..l+2, TokenColor::Keyword);
        TokenColor::fill_colors(colors, then_l..then_r, TokenColor::Keyword);
        TokenColor::fill_colors(colors, else_l..else_r, TokenColor::Keyword);
        match cond {
            Some(c) => WithLocation::new(TypeAst::Apply {
                func: Box::new(WithLocation::new(TypeAst::Match {
                    branches: vec![
                        (WithLocation::new(TypeAst::Bottom, Some(SourceLocation::new(source.clone(), l..r)).as_ref()), else_branch),
                        (WithLocation::new(TypeAst::Top, Some(SourceLocation::new(source.clone(), l..r)).as_ref()), then_branch),
                    ],
                }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
                arg: Box::new(c),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
            None => WithLocation::new(TypeAst::Match {
                branches: vec![
                    (WithLocation::new(TypeAst::Bottom, Some(SourceLocation::new(source.clone(), l..r)).as_ref()), else_branch),
                    (WithLocation::new(TypeAst::Top, Some(SourceLocation::new(source.clone(), l..r)).as_ref()), then_branch),
                ],
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),    
        }
    },
}

Match: WithLocation<TypeAst> = {
    <l:@L> "match" <value: Primary?> <branches: MatchBranch*> <v_l:@L> "|" <v_r:@R> "panic" <r:@R> => {
        TokenColor::fill_colors(colors, l..l+5, TokenColor::Keyword);
        TokenColor::fill_colors(colors, v_l..v_r, TokenColor::Operator);
        TokenColor::fill_colors(colors, r-5..r, TokenColor::Keyword);
        match value {
            Some(v) => WithLocation::new(TypeAst::Apply {
                func: Box::new(WithLocation::new(TypeAst::Match {
                    branches: branches,
                }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
                arg: Box::new(v),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
            None => WithLocation::new(TypeAst::Match {
                branches: branches,
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
        }
    },
}

MatchBranch: (WithLocation<TypeAst>, WithLocation<TypeAst>) = {
    <pipe_l:@L> "|" <pipe_r:@R> <pattern: Primary> <arrow_l:@L> "=>" <arrow_r:@R> <t: Primary> => {
        TokenColor::fill_colors(colors, pipe_l..pipe_r, TokenColor::Operator);
        TokenColor::fill_colors(colors, arrow_l..arrow_r, TokenColor::Operator);
        (pattern, t)
    },
}


RecursiveGen: WithLocation<TypeAst> = {
    <l:@L> "rec" <id: Ident> <c_l: @L> ":" <c_r:@R> <t: Primary> <r:@R> => {
        TokenColor::fill_colors(colors, c_l..c_r, TokenColor::Operator);
        TokenColor::fill_colors(colors, l..l+3, TokenColor::Keyword);
        WithLocation::new(TypeAst::FixPoint {
            param_name: id,
            expr: Box::new(t),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
}

Closure: WithLocation<TypeAst> = {
    <l:@L> <pattern: Factor> <arrow_l:@L> "->" <arrow_r:@R> <body: Primary> <r:@R> => {
        TokenColor::fill_colors(colors, arrow_l..arrow_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Match {
            branches: vec![(pattern, body)],
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
}

Tuple: WithLocation<TypeAst> = {
    <l:@L> <r:@R> => WithLocation::new(TypeAst::Tuple(vec![]), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <l:@L> <items: Comma<TupleElement>> <r:@R> => WithLocation::new(TypeAst::Tuple(items), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <item: TupleElement> => item,
}

// Define Comma<T> for one or more comma-separated items.
Comma<T>: Vec<T> = {
    <v:(T CommaSep)+> <e:T> => {
        let mut res = Vec::new();
        for (it, _sep) in v.into_iter() {
            res.push(it);
        }
        res.push(e);
        res
    },
    <e:T> CommaSep => vec![e],
};

CommaSep: () = <l:@L> ","+ <r:@R> => {
    TokenColor::fill_colors(colors, l..r, TokenColor::Punctuation);
    ()
};


Literal: WithLocation<TypeAst> = {
    <l:@L> <hash_l:@L> "#" <hash_r:@R> <t: Primary> <r:@R> => {
        TokenColor::fill_colors(colors, hash_l..hash_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Literal(Box::new(t)), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
}

Primary: WithLocation<TypeAst> = {
    <l: Literal> => l,
    <l: List> => l,
    <r: RecursiveGen> => r,
    <c: Closure> => c,
    <m: Match> => m,
    <i: IfElse> => i,
    <c: Calculate> => c,
    ! => {
        let err: ErrorRecovery<usize, LexerToken, LexicalError> = <>;
        let (l, r) = calculate_full_error_span(&err);
        TokenColor::fill_colors(colors, l..r, TokenColor::Error);
        WithLocation::new(TypeAst::ParseError(err), None::<&SourceLocation>)
    }
};

Factor: WithLocation<TypeAst> = {
    <l:@L> <op_l:@L> "!" <op_r:@R> <a: Factor> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Not {
            value: Box::new(a),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <op_l:@L> "-" <op_r:@R> <n: Factor> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Neg), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(n),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <def_l:@L> <id: Ident> <def_r:@R> <colon_l:@L> ":" <colon_r:@R> <a: Factor> <r:@R> => {
        TokenColor::fill_colors(colors, def_l..def_r, TokenColor::Declaration);
        TokenColor::fill_colors(colors, colon_l..colon_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Pattern {
            name: id,
            expr: Box::new(a),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <a: Apply> => a,
}


TupleElement = Generalize;

Generalize: WithLocation<TypeAst> = {
    <l:@L> <items: Bars<Specialize>> <r:@R> => WithLocation::new(TypeAst::Generalize(items), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <e: Specialize> => e,
}

Bars<T>: Vec<T> = {
    <v:(T BarsSep)+> <e:T> => {
        let mut res = Vec::new();
        for (it, _sep) in v.into_iter() {
            res.push(it);
        }
        res.push(e);
        res
    },
};

BarsSep: () = <l:@L> "|"+ <r:@R> => {
    TokenColor::fill_colors(colors, l..r, TokenColor::Operator);
    ()
};

Specialize: WithLocation<TypeAst> = {
    <l:@L> <items: Ands<Primary>> <r:@R> => WithLocation::new(TypeAst::Specialize(items), Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
    <e: Primary> => e,
}

Ands<T>: Vec<T> = {
    <v:(T AndsSep)+> <e:T> => {
        let mut res = Vec::new();
        for (it, _sep) in v.into_iter() {
            res.push(it);
        }
        res.push(e);
        res
    },
    <e:T> AndsSep => vec![e],
};

AndsSep: () = <l:@L> "&"+ <r:@R> => {
    TokenColor::fill_colors(colors, l..r, TokenColor::Operator);
    ()
};


Calculate: WithLocation<TypeAst> = { Compare };

Compare: WithLocation<TypeAst> = {
    <l:@L> <left: Compare> <op_l:@L> "==" <op_r:@R> <right: AddSub> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Eq {
            left: Box::new(left),
            right: Box::new(right),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <left: Compare> <op_l:@L> "!=" <op_r:@R> <right: AddSub> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Neq {
            left: Box::new(left),
            right: Box::new(right),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <left: Compare> <op_l:@L> "<" <op_r:@R> <right: AddSub> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Less), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <left: Compare> <op_l:@L> "<=" <op_r:@R> <right: AddSub> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Generalize(vec![
            WithLocation::new(TypeAst::Apply {
                func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Less), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
                arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left.clone(), right.clone()]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
            WithLocation::new(TypeAst::Eq {
                left: Box::new(left),
                right: Box::new(right),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
        ]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <left: Compare> <op_l:@L> ">" <op_r:@R> <right: AddSub> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Greater), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <left: Compare> <op_l:@L> ">=" <op_r:@R> <right: AddSub> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Generalize(vec![
            WithLocation::new(TypeAst::Apply {
                func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Greater), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
                arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left.clone(), right.clone()]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
            WithLocation::new(TypeAst::Eq {
                left: Box::new(left),
                right: Box::new(right),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
        ]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <left: Compare> <op_l:@L> "<:" <op_r:@R> <right: AddSub> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Is), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <t: AddSub> => t,
}

AddSub: WithLocation<TypeAst> = {
    <l:@L> <left: AddSub> <op_l:@L> "+" <op_r:@R> <right: Mod> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Add), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <left: AddSub> <op_l:@L> "-" <op_r:@R> <right: Mod> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Sub), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <t: Mod> => t,
}

Mod: WithLocation<TypeAst> = {
    <l:@L> <left: Mod> <op_l:@L> "%" <op_r:@R> <right: MulDiv> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Mod), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <t: MulDiv> => t,
}

MulDiv: WithLocation<TypeAst> = {
    <l:@L> <left: MulDiv> <op_l:@L> "*" <op_r:@R> <right: Factor> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Mul), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <left: MulDiv> <op_l:@L> "/" <op_r:@R> <right: Factor> <r:@R> => {
        TokenColor::fill_colors(colors, op_l..op_r, TokenColor::Operator);
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::AtomicOpcode(crate::parser::ast::AtomicOpcode::Div), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(WithLocation::new(TypeAst::Tuple(vec![left, right]), Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <t: Factor> => t,
}


Let: (WithLocation<TypeAst>, WithLocation<TypeAst>) = {
    <l:@L> "let" <id: Primary> <a_l:@L> "=" <a_r:@R> <value: Type> ";" <r:@R> => {
        TokenColor::fill_colors(colors, l..l+3, TokenColor::Keyword);
        TokenColor::fill_colors(colors, a_l..a_r, TokenColor::Operator);
        TokenColor::fill_colors(colors, r-1..r, TokenColor::Punctuation);
        (id, value)
    },
}

Discard: WithLocation<TypeAst> = {
    <l:@L> "discard" <e: Type> ";" <r:@R> => {
        TokenColor::fill_colors(colors, l..l+7, TokenColor::Keyword);
        TokenColor::fill_colors(colors, r-1..r, TokenColor::Punctuation);
        e
    },
}

Recursive: (String, WithLocation<TypeAst>, WithLocation<TypeAst>) = {
    // loop label: pattern = initialize_value;
    <l:@L> "loop" <id: Ident> <c_l:@L> ":" <c_r:@R> <t: Type> <e_l:@L> "=" <e_r:@R> <expr: Type> ";" <r:@R> => {
        TokenColor::fill_colors(colors, l..l+4, TokenColor::Keyword);
        TokenColor::fill_colors(colors, c_l..c_r, TokenColor::Operator);
        TokenColor::fill_colors(colors, e_l..e_r, TokenColor::Operator);
        TokenColor::fill_colors(colors, r-1..r, TokenColor::Punctuation);
        (id, t, expr)
    },
}

Expression: WithLocation<TypeAst> = {
    <l:@L> "let" <arg: Type> <con_l:@L> ";" <con_r:@R> <expr: Type> <r:@R> => {
        TokenColor::fill_colors(colors, l..l+7, TokenColor::Keyword);
        TokenColor::fill_colors(colors, con_l..con_r, TokenColor::Punctuation);
        WithLocation::new(TypeAst::Match {
            branches: vec![(arg, expr)],
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> <let_expr: Let> <e: Type> <r:@R> => {
        match e.value() {
            TypeAst::Expression {
                binding_patterns,
                binding_types,
                body,
            } => {
                let mut new_patterns = binding_patterns.clone();
                let mut new_types = binding_types.clone();
                new_patterns.insert(0, let_expr.0);
                new_types.insert(0, let_expr.1);
                WithLocation::new(TypeAst::Expression {
                    binding_patterns: new_patterns,
                    binding_types: new_types,
                    body: body.clone(),
                }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
            }
            _ => WithLocation::new(TypeAst::Expression {
                binding_patterns: vec![let_expr.0],
                binding_types: vec![let_expr.1],
                body: Box::new(e),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
        }
    },
    <l:@L> <discard_expr: Discard> <e: Type> <r:@R> => {
        match e.value() {
            TypeAst::Expression {
                binding_patterns,
                binding_types,
                body,
            } => {
                let mut new_patterns = binding_patterns.clone();
                let mut new_types = binding_types.clone();
                new_patterns.insert(0, WithLocation::new(TypeAst::DiscardPattern, Some(SourceLocation::new(source.clone(), l..r)).as_ref()));
                new_types.insert(0, discard_expr);
                WithLocation::new(TypeAst::Expression {
                    binding_patterns: new_patterns,
                    binding_types: new_types,
                    body: body.clone(),
                }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
            }
            _ => WithLocation::new(TypeAst::Expression {
                binding_patterns: vec![WithLocation::new(TypeAst::DiscardPattern, Some(SourceLocation::new(source.clone(), l..r)).as_ref())],
                binding_types: vec![discard_expr],
                body: Box::new(e),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref()),
        }
    },
}

Loop: WithLocation<TypeAst> = {
    <l:@L> <rec_expr: Recursive> <e: Type> <r:@R> => {
        WithLocation::new(TypeAst::Apply {
            func: Box::new(WithLocation::new(TypeAst::FixPoint {
                param_name: rec_expr.0,
                expr: Box::new(WithLocation::new(TypeAst::Match {
                    branches: vec![(rec_expr.1, e)],
                }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            arg: Box::new(rec_expr.2),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
}

HandleWith: WithLocation<TypeAst> = {
    <l:@L> "handle" <id: Primary> <a_l:@L> "=" <a_r:@R> <value: Type> <with_l:@L> "with" <with_r:@R> <handler: Type> <con_l:@L> ";" <con_r:@R> <expr: Type> <r:@R> => {
        TokenColor::fill_colors(colors, l..l+6, TokenColor::Keyword);
        TokenColor::fill_colors(colors, a_l..a_r, TokenColor::Operator);
        TokenColor::fill_colors(colors, with_l..with_r, TokenColor::Keyword);
        TokenColor::fill_colors(colors, con_l..con_r, TokenColor::Punctuation);
        WithLocation::new(TypeAst::HandleWith {
            closure: Box::new(WithLocation::new(TypeAst::Match {
                branches: vec![(id, expr)],
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            init_val: Box::new(value),
            handler: Box::new(handler),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
    <l:@L> "handle" <with_l:@L> "with" <with_r:@R> <handler: Type> <con_l:@L> ";" <con_r:@R> <expr: Type> <r:@R> => {
        TokenColor::fill_colors(colors, l..l+6, TokenColor::Keyword);
        TokenColor::fill_colors(colors, with_l..with_r, TokenColor::Keyword);
        TokenColor::fill_colors(colors, con_l..con_r, TokenColor::Punctuation);
        WithLocation::new(TypeAst::HandleWith {
            closure: Box::new(WithLocation::new(TypeAst::Match {
                branches: vec![(
                    WithLocation::new(TypeAst::DiscardPattern, Some(SourceLocation::new(source.clone(), l..r)).as_ref()), expr
                )],
            }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())),
            init_val: Box::new(
                WithLocation::new(TypeAst::DiscardPattern,
                Some(SourceLocation::new(source.clone(), l..r)).as_ref())
            ),
            handler: Box::new(handler),
        }, Some(SourceLocation::new(source.clone(), l..r)).as_ref())
    },
}


pub Type: WithLocation<TypeAst> = {
    <h: HandleWith> => h,
    <l: Loop> => l,
    <e: Expression> => e,
    <t: Tuple> => t,
}
